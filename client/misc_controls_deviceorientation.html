<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - controls - deviceorientation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="user-scalable=no, initial-scale=1">
    <style>
        body {
            margin: 0px;
            background-color: #000000;
            overflow: hidden;
        }

    </style>
</head>
<body>

<script src="js/libs/three.js"></script>
<script src="js/controls/DeviceOrientationControls.js"></script>

<script>

    var camera, scene, renderer, controls;

    init();
    animate();

    function init() {

        //创建一个透视相机
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);

        //构造一个方向控制器
        controls = new THREE.DeviceOrientationControls(camera);

        scene = new THREE.Scene();

        //创建一个球型几何体
        var geometry = new THREE.SphereBufferGeometry(500, 60, 40);
        // invert the geometry on the x-axis so that all of the faces point inward 在x轴上反转几何形状，这样所有的面都指向内
        geometry.scale(-1, 1, 1);

        var material = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load('js/textures/2294472375_24a3b8ef46_o.jpg')
        });

        var mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        var helperGeometry = new THREE.BoxBufferGeometry(100, 100, 100, 4, 4, 4);
        var helperMaterial = new THREE.MeshBasicMaterial({color: 0xff00ff, wireframe: true});
        var helper = new THREE.Mesh(helperGeometry, helperMaterial);
        scene.add(helper);

        //创建一个渲染器，开启抗锯齿效果
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);//设置设备像素比。这是通常用于HiDPI设备，以防止彩色输出画布
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        //

        window.addEventListener('resize', onWindowResize, false);


    }

    function animate() {

        window.requestAnimationFrame(animate);

        controls.update();
        renderer.render(scene, camera);

    }

    function onWindowResize() {

        //aspect：相机截屏长宽比
        camera.aspect = window.innerWidth / window.innerHeight;
        //更新相机投影矩阵。必须在参数发生任何更改后调用。
        camera.updateProjectionMatrix();

        //浏览器视口（viewport）宽度和高度
        renderer.setSize(window.innerWidth, window.innerHeight);

    }

</script>
</body>
</html>
